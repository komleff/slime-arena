# Техническое задание: Исправление мультитач-управления (Mobile Controls)

**Версия:** 1.0.0  
**Дата:** 7 января 2026  
**Статус:** Черновик  
**Приоритет:** P0 (Critical)  

---

## Резюме

Текущая реализация управления на мобильных устройствах блокирует одновременное использование джойстика движения и кнопок способностей. Документ описывает требования к изменению логики обработки ввода для поддержки [Multitouch] сценариев и устранения [Movement Lock].

---

## 1. Цели

1.  **Обеспечить мультитач:** Игрок [MUST] иметь возможность активировать способности, не прерывая движение джойстиком.
2.  **Снизить задержку:** Активация способностей [SHOULD] происходить по событию нажатия (`pointerdown`), а не отпускания (`click`).
3.  **Сохранить надежность:** Механизм предотвращения «залипания» джойстика [MUST] работать корректно, сбрасывая состояние только при реальных конфликтах ввода.

---

## 2. Контекст

В модуле `client/src/main.ts` функция `forceResetJoystickForAbility` выполняет безусловный сброс [JoystickState] при любой активации способности. Это было сделано для защиты от гонки событий (touch vs mouse compatibility events), но приводит к мгновенной остановке персонажа, если игрок использует два пальца одновременно.

---

## 3. Компоненты

| Компонент | Описание | Роль в изменениях |
|-----------|----------|-------------------|
| **InputController** (`main.ts`) | Обработчик глобального ввода | Содержит проблемную функцию `forceResetJoystickForAbility` |
| **JoystickModule** (`input/joystick.ts`) | Логика виртуального джойстика | Хранит `pointerId` активного касания |
| **AbilityUI** (Legacy & Preact) | Кнопки интерфейса | Источник событий активации |

---

## 4. Детали реализации

### 4.1. Изменение обработки событий UI [MUST]

1.  Все кнопки способностей (Legacy DOM и Preact компоненты) должны обрабатывать событие `pointerdown` вместо `click`.
2.  Обработчик события должен извлекать `pointerId` из объекта `PointerEvent`.
3.  Вызов функции активации способности должен передавать этот `pointerId`.

### 4.2. Логика условного сброса джойстика [MUST]

Функция `forceResetJoystickForAbility` (или её аналог) должна быть модифицирована для проверки конфликта указателей.

**Алгоритм:**

1.  **Входные данные:** `abilitySlot` (number), `triggerPointerId` (number).
2.  **Проверка активности:** Если [JoystickState].active == `false`, выход из функции (сброс не требуется).
3.  **Проверка конфликта:**
    *   **Если** [JoystickState].pointerId == `triggerPointerId`:
        *   Это один и тот же палец (пользователь сдвинул палец с джойстика на кнопку).
        *   **Действие:** Выполнить полный сброс джойстика (`detach` + `reset`).
    *   **Если** [JoystickState].pointerId != `triggerPointerId`:
        *   Это разные пальцы (мультитач).
        *   **Действие:** Не сбрасывать джойстик. Игнорировать вызов.

### 4.3. Формирование пакета ввода (Input Packet) [MUST]

При отправке команды `input` с типом `abilitySlot`:

1.  **Если** джойстик активен (и не был сброшен на шаге 4.2):
    *   В поля `moveX`, `moveY` пакета записать текущие значения из [JoystickState].
2.  **Иначе**:
    *   Использовать (0, 0) или последнее известное значение `lastSentInput` (если требуется инерция).

---

## 5. Глоссарий

*   **[Multitouch]**: Режим ввода, при котором экран распознает два и более одновременных касания.
*   **[JoystickState]**: Объект, хранящий состояние виртуального джойстика (активен ли, координаты, ID указателя).
*   **[Movement Lock]**: Ситуация, когда персонаж перестает двигаться из-за программного сброса ввода, хотя игрок продолжает удерживать джойстик.

---

## 6. Открытые вопросы

1.  Требуется ли обновление `AbilityButtons.tsx` (Preact) для поддержки `pointerdown`? (Рекомендуется для унификации UX и снижения Input Lag).
2.  Нужно ли сохранять `lastSentInput` при сбросе джойстика для сглаживания остановки? (Сейчас сбрасывается в 0,0).