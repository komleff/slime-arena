# ТЗ: Минимальный мета-геймплей (MVP)

**Версия:** 1.0 
**Дата:** 21.01.2026 
**Автор:** Gemini 3 Pro
**Основание:** Запрос на внедрение авторизации и рейтинга. 
**Контекст:** Slime Arena v0.6.0, Architecture v4.2.5.

## 1. Цели и задачи

Реализовать базовый цикл удержания игрока (Meta-Loop) через сохранение прогресса. **Ключевые фичи:**

1. **Авторизация:** Поддержка "тихой" (платформенной) и явной (Google/Yandex) авторизации.
2. **Профиль:** Хранение ника и фиксированного скина.
3. **Рейтинг:** Накопительная система (сумма массы за все игры).
4. **Конверсия:** Мягкое вовлечение гостя в регистрацию через экран результатов.

## 2. Пользовательские сценарии (User Flow)

### 2.1. Новый игрок (Гостевой вход)

1. **Вход:** Игрок открывает игру по прямой ссылке.
2. **Лобби:**
   - Игрок попадает в Лобби как "Гость".
   - **Ник:** Генерируется случайно (напр., "Slime_1234").
   - **Скин:** Генерируется случайно.
   - **UI:** В правом верхнем углу кнопка "Войти" (Login) — маленькая, не акцентная.
3. **Матч:** Игрок выбирает класс, нажимает "Играть", проводит бой.
4. **Результаты (Moment of Truth):**
   - Показывается набранная масса (напр., 1200 кг).
   - **Похвала:** Текст "Отличный результат для новичка!".
   - **Оффер:** "Сохрани прогресс и получи этот счастливый скин в подарок!".
   - **Кнопки:**
     - (А) **"Сохранить!"** (Акцентная/Primary) -> Переход к экрану Регистрации.
     - (Б) **"Сыграть еще"** (Вторичная/Secondary) -> Возврат в Лобби.
5. **Действие (Б):** Игрок возвращается в Лобби. Ник и класс можно менять. Скин остается случайным (тем же, что был). Прогресс (масса) *локально* не отображается в глобальном рейтинге, пока не будет регистрации.

### 2.2. Регистрация (Сохранение прогресса)

1. **Триггер:** Нажатие кнопки "Сохранить!" на экране результатов (или "Войти" в Лобби).
2. **Экран Регистрации:**
   - Если платформа (Telegram/VK/Yandex.Games): "Тихая" регистрация через нативное API платформы.
   - Если Web (прямая ссылка): Модальное окно с выбором провайдера (Google, Yandex).
3. **Настройка профиля:**
   - После успешной OAuth авторизации показывается окно "Создание профиля".
   - Поле ввода **Ника** (предзаполняется текущим случайным или данными из соцсети).
   - Отображение текущего **Скина** (подпись: "Ваш уникальный скин").
   - Кнопка "Готово".
4. **Фиксация:**
   - Создается аккаунт в БД.
   - Текущий скин записывается как `selected_skin_id`.
   - Результат последнего матча (масса) записывается в рейтинг игрока.
5. **Редирект:** Игрок попадает в Лобби уже как авторизованный пользователь.

### 2.3. Повторный вход (Returning User)

1. **Сценарий А (Куки есть / Платформа):**
   - При загрузке (`BootScreen`) происходит тихая авторизация.
   - Игрок попадает в Лобби со своим ником, скином и рейтингом.
2. **Сценарий Б (Новый браузер / Инкогнито):**
   - Игрок попадает в Лобби как Гость (новый случайный скин/ник).
   - Нажимает кнопку "Войти" (в углу).
   - Проходит авторизацию -> Профиль подгружается -> Скин и Рейтинг восстанавливаются.

## 3. Изменения в UI (Frontend)

### 3.1. LobbyScreen

- **Top-Right Corner:** Добавить кнопку `[Войти]` (иконка двери/логина). Скрывать, если пользователь уже авторизован.
- **Скин:** Отображать текущий скин (случайный для гостя, сохраненный для юзера).
- **Рейтинг:** Отображать текущий рейтинг (сумма массы) под ником. Для гостя — 0 или скрыто.

### 3.2. ResultsScreen

- Добавить логику отображения для **неавторизованного** пользователя:
  - Блок "Call to Action":
    - Текст: "Сохрани <MASS> очков рейтинга и этот скин!"
    - Кнопка: `[Сохранить прогресс]` (Primary).
    - Кнопка: `[Сыграть еще]` (Secondary).

### 3.3. AuthModal / AuthScreen (Новый компонент)

- Реализовать модальное окно (или экран) для Web-версии.
- Кнопки провайдеров: `[Google]`, `[Yandex]`.
- Поле редактирования ника перед завершением.

## 4. Серверная логика (Backend)

### 4.1. База данных (PostgreSQL)

Использовать существующую схему (Architecture Part 4) с уточнениями:

1. **Table `users`:**
   - `platform_type`: добавить поддержку типа `'guest'` (если требуется временная сессия) или просто не создавать запись до явной регистрации.
   - *Решение:* Не создаем запись в БД для гостя. Гость живет только в памяти клиента (localStorage). Запись создается только при явной авторизации.
2. **Table `profiles`:**
   - `selected_skin_id`: При регистрации сюда пишется ID скина, с которым играл гость. В MVP скин менять нельзя (только при первой регистрации фиксируется).
3. **Table `player_ratings`:**
   - **Важное изменение логики:** Вместо Glicko-2 пока используем накопительную сумму.
   - `rating`: `INT`, Default 0.
   - Логика обновления: `rating = rating + match_final_mass`.

### 4.2. API Endpoints (MetaServer)

1. **`POST /api/v1/auth/verify` (Существующий):**
   - Доработать для Web: принимать токены от Google/Yandex.
   - В ответе возвращать флаг `isNewUser`.
2. **`POST /api/v1/profile/register` (Новый/Уточнение):**
   - Используется для завершения регистрации (установка ника и сохранение первого скина).
   - **Body:** `{ "nickname": "...", "skinId": "...", "initialMass": 1200 }`
   - *Примечание:* `initialMass` — это масса с последнего матча, которую мы "сохраняем".
   - *Безопасность:* В будущем `initialMass` нужно валидировать через signed token матча, но для MVP можно доверять клиенту (или передавать `matchId`, чтобы сервер сам посмотрел результат).
   - **Рекомендация:** Передавать `lastMatchId`. Сервер находит результат матча в `match_results` и, если он принадлежит этому (ранее анонимному) сокету/сессии, добавляет массу в рейтинг.
   - *Упрощение для MVP:* Передавать массу в теле запроса (с пониманием рисков чита).
3. **`POST /api/v1/match/end` (Webhook от MatchServer):**
   - Когда матч заканчивается, MatchServer шлет результаты на MetaServer.
   - Если `userId` существует (игрок авторизован) -> Обновить `player_ratings`: `rating += mass`.
   - Если `userId` нет (гость) -> Ничего не писать в БД.

## 5. Логика Рейтинга (Временная)

Вместо сложной ELO/Glicko системы, описанной в Архитектуре, временно внедряем линейную прогрессию:

- **Формула:** `TotalRating += MatchEndMass`.
- **Пример:**
  - Игра 1: Закончил с 150 кг. Рейтинг: 150.
  - Игра 2: Закончил с 800 кг. Рейтинг: 950.
  - Игра 3: Умер (50 кг). Рейтинг: 1000.
- Рейтинг никогда не падает.

## 6. Технические требования

1. **Auth Providers:**
   - Использовать Firebase Auth (как самое простое решение для Web frontend) ИЛИ Passport.js на бэкенде.
   - Для Telegram Mini Apps — валидация `initData` (уже заложено в архитектуре).
2. **Persistence:**
   - Использовать `localStorage` для хранения состояния "Гость" (генерированный ник/скин), чтобы при обновлении страницы они не менялись до регистрации.
3. **Skin Generation:**
   - Клиент генерирует `skinId` (комбинация цвета/глаз/рта) при первом запуске.
   - Этот `skinId` отправляется на сервер при регистрации.

## 7. План работ

1. **Client:** Реализовать генерацию гостевого профиля (Local Storage).
2. **Client:** Верстка кнопки Login в лобби и экрана "Сохранить прогресс" в Results.
3. **Client:** Интеграция Firebase Auth (или аналога) для Google/Yandex.
4. **Server:** Настройка `player_ratings` на суммирование массы.
5. **Server:** Эндпоинт регистрации с сохранением переданного скина.