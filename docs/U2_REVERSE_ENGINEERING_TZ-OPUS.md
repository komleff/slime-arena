# U2 — Реверс-инженеринг: Техническое задание

> Документ описывает архитектуру и логику ключевых модулей проекта [komleff/u2](https://github.com/komleff/u2).

---

## 1. Физика полета

### 1.1 Общая архитектура

Система использует **релятивистскую кинематику** с переменной скоростью света (c'). Интеграция происходит на сервере в `PhysicsSystem` (ECS, Entitas) с фиксированным тиком 30 Hz.

### 1.2 Основные принципы

| Аспект | Описание |
|--------|----------|
| Модель движения | Импульсная (momentum-based) |
| Переменная c' | Локальная скорость света, по умолчанию 5000 m/s |
| Ограничение скорости | 0.99 × c' (жёсткий предел) |
| Интегратор | Euler первого порядка на каждом тике |

### 1.3 Релятивистская математика

**Преобразование скорость → импульс:**
$$p = m \cdot v \cdot \gamma$$

где $\gamma = \frac{1}{\sqrt{1 - v^2/c'^2}}$ — фактор Лоренца.

**Обратное преобразование импульс → скорость:**

Используется итерационный метод Newton-Raphson (5 итераций) для численного решения уравнения $p = m \cdot v \cdot \gamma(v)$.

### 1.4 Цикл интеграции

1. **Получить силу** из `PhysicsGateway` на основе управляющих сигналов
2. **Преобразовать силу в изменение импульса**: $\Delta p = F \cdot dt$
3. **Обновить импульс**: $p_{new} = p_{old} + \Delta p$
4. **Преобразовать импульс в скорость** (Newton-Raphson)
5. **Ограничить скорость** до 0.99 × c'
6. **Обновить позицию**: $x_{new} = x_{old} + v \cdot dt$
7. **Интегрировать угловую скорость** аналогично (без релятивистских эффектов)

### 1.5 Вычисление сил

`PhysicsGateway` преобразует нормализованные входы [-1, 1] в физические силы:

- **Тяга (Thrust)**: `input.thrust × ThrustForce_Forward_MN × 10⁶` [Н]
- **Strafe X**: `input.strafeX × ThrustForce_Lateral_MN × 10⁶` [Н]
- **Strafe Y** (brake): `input.strafeY × ThrustForce_Reverse_MN × 10⁶` [Н]
- **Yaw**: `input.yaw × AngularAcceleration_Yaw_dps2` [°/s²]

Силы применяются в локальной системе координат корабля, затем преобразуются в мировую.

---

## 2. ТТХ кораблей и параметры Default Ship

### 2.1 Структура конфигурации (v0.8.7)

Конфигурация корабля (`ShipConfig`) включает четыре блока:

| Блок | Назначение |
|------|------------|
| Hull | Масса, прочность, геометрия |
| Propulsion | Силы тяги, угловые ускорения |
| FlightAssist | Лимиты скорости и ускорения для FA:ON |
| Geometry | Габариты для расчёта коллизий |

### 2.2 Default Fighter — полный набор параметров

#### Hull
| Параметр | Значение | Единицы |
|----------|----------|---------|
| DryMass | 10 | t (тонн) |
| MaxCargoMass | 0 | t |
| Hull_HP | 1000 | HP |

#### Geometry
| Параметр | Значение | Единицы |
|----------|----------|---------|
| Length | 11.5 | m |
| Width | 11.0 | m |
| Height | 3.5 | m |

#### Propulsion (на основе силы)

| Направление | Ускорение | Сила (расчётная) |
|-------------|-----------|------------------|
| Forward | 90 | m/s² | 0.9 MN |
| Reverse | 67.5 | m/s² | 0.675 MN |
| Lateral | 85 | m/s² | 0.85 MN |

| Ось вращения | Угловое ускорение |
|--------------|-------------------|
| Yaw | 200 °/s² |
| Pitch | 180 °/s² |
| Roll | 220 °/s² |

#### FlightAssist Limits

| Параметр | Значение | Единицы |
|----------|----------|---------|
| SpeedLimit_Forward | 260 | m/s |
| SpeedLimit_Reverse | 180 | m/s |
| SpeedLimit_Lateral | 220 | m/s |
| AngularSpeedLimit_Yaw | 100 | °/s |
| CrewGLimit | 11 | g |
| ComfortableBrakingTime | 3.5 | s |
| AngularStopTime | 1.0 | s |

#### Окружение

| Параметр | Значение |
|----------|----------|
| c' (Speed of Light) | 5000 m/s |
| Physics Tick Rate | 30 Hz (server), 60 Hz (client prediction) |

### 2.3 Загрузка конфигурации

Параметры загружаются из `physics.json` через `SharedPhysics.LoadConfig()`. При отсутствии файла используются значения по умолчанию (Default Fighter).

---

## 3. Принцип управления кораблем

### 3.1 Входные данные

Система принимает нормализованные команды:

| Команда | Диапазон | Описание |
|---------|----------|----------|
| thrust | [0, 1] | Тяга вперёд |
| strafeX | [-1, 1] | Боковое перемещение (лево/право) |
| strafeY | [-1, 1] | Торможение (отрицательные значения) |
| yaw | [-1, 1] | Рыскание (поворот) |
| flightAssist | bool | Режим FA:ON/OFF |
| brake | bool | Активное торможение |

### 3.2 Путь обработки ввода

```
[Input Device] → [InputManager] → [CommandFrame] → [NetworkStateManager] → [Server]
                                        ↓
                              [PredictionEngine] (client-side)
```

1. **InputManager** собирает ввод с клавиатуры/геймпада/тачскрина
2. Формируется **CommandFrame** с timestamp и sequence number
3. **PredictionEngine** применяет ввод локально (client-side prediction)
4. Команда отправляется на сервер через WebSocket
5. Сервер обрабатывает в `FlightAssistSystem` → `PhysicsSystem`

### 3.3 Нормализация и валидация

- Вектор движения ограничивается и нормализуется при magnitude > 1
- `deltaTime` ограничивается (`MAX_DELTA_TIME`) для предотвращения скачков после паузы
- Устаревшие команды (по `seq`) отклоняются сервером

---

## 4. Flight Assist и его режимы полета

### 4.1 Режимы работы

| Режим | Описание |
|-------|----------|
| FA:ON | Стабилизация, ограничение скорости, ограничение перегрузок |
| FA:OFF | Прямое управление без ограничений |
| BRAKE | Агрессивное торможение (подрежим FA:ON) |

### 4.2 FA:OFF — Raw Physics

При отключённом Flight Assist:
- Входные сигналы ограничиваются диапазоном [-1, 1]
- Передаются напрямую в `PhysicsGateway`
- Нет ограничений скорости (кроме 0.99 × c')
- Нет демпфирования угловой скорости
- Нет защиты от перегрузок

### 4.3 FA:ON — Stabilization Mode

**Логика ограничения скорости:**

1. Определить текущую скорость по осям (forward, lateral, reverse)
2. Сравнить с лимитами из `FlightAssist` конфигурации
3. Если скорость превышает лимит — рассчитать требуемое торможение
4. Ограничить торможение по `CrewGLimit`

**Демпфирование угловой скорости:**

При отсутствии управляющего ввода по оси вращения:
$$\omega_{new} = \omega_{old} \cdot e^{-k \cdot dt}$$

где $k$ — коэффициент демпфирования, вычисляемый из `AngularStopTime`.

**Ограничение перегрузок (G-Limit):**

Суммарное ускорение ограничивается:
$$a_{total} \leq G_{limit} \cdot g$$

где $g = 9.81$ m/s².

### 4.4 BRAKE — Aggressive Deceleration

Активируется при `strafeY < -0.5` или нажатии кнопки brake:
- Рассчитывается вектор торможения, противоположный текущей скорости
- Применяется максимальное доступное ускорение (с учётом G-Limit)
- Цель — остановка за `ComfortableBrakingTime`

### 4.5 Порядок обработки в тике

1. `FlightAssistSystem.Execute()` — преобразование команд с учётом режима
2. `PhysicsSystem.Execute()` — интеграция физики
3. `CollisionSystem.Execute()` — обработка столкновений

---

## 5. Логика ассистента управления в мобильном режиме

### 5.1 Архитектура модуля

Мобильное управление реализовано в клиентском модуле `InputTranslator_DirectControl`:

| Компонент | Ответственность |
|-----------|-----------------|
| TouchInputManager | Обработка касаний, dual joystick |
| SingleJoystickManager | Fly-by-wire с одним джойстиком |
| InputTranslator | Преобразование ввода в команды |
| ModeTransition | Плавные переходы между режимами |
| AutopilotController | Демо-автопилот |

### 5.2 Dual Joystick (TouchInputManager)

**Раскладка:**
- **Левый джойстик**: thrust (вверх) + strafeX (лево/право)
- **Правый джойстик**: yaw (лево/право)
- **Кнопки**: BRAKE, FA toggle, AUTO toggle

**Обработка мёртвой зоны:**
- DeadZone: 15% от радиуса джойстика
- Значения внутри зоны обнуляются
- Значения снаружи линейно масштабируются к [0, 1]

**Адаптивная раскладка:**
- Позиция джойстиков подстраивается под размер экрана
- Haptic feedback при активации зон

### 5.3 Single Joystick (SingleJoystickManager)

Режим fly-by-wire с адаптивным демпфированием yaw:

**Алгоритм:**
1. Направление джойстика → целевой heading
2. Разница между текущим и целевым heading → yaw input
3. При FA:OFF применяется дополнительное демпфирование для предотвращения осцилляций

**Детектирование осцилляций:**
- Отслеживается количество смен знака yaw за последние N кадров
- При превышении порога — увеличивается демпфирование

### 5.4 InputTranslator — режимы управления

| Режим | Условие активации | Поведение |
|-------|-------------------|-----------|
| FREE_FLIGHT | Нет валидной цели | Джойстик → thrust/strafe |
| COMBAT_LOCK | Есть враждебная цель | Автонаведение на цель |

**Переход между режимами:**
- Длительность перехода: 300 ms (настраиваемо)
- Линейная интерполяция всех параметров
- `brake` — OR от обоих режимов
- `flightAssist` — берётся из целевого режима

### 5.5 Валидация цели

Цель считается валидной если:
- `targetEntity !== null`
- `isHostile === true`
- `isAlive === true`
- Дистанция в пределах допустимого диапазона

---

## 6. Алгоритм предиктивного сглаживания

### 6.1 Проблема

Линейная интерполяция между снапшотами создаёт «углы» при смене направления движения сущностей.

### 6.2 Решение — Predictive Hermite Curves (v0.13)

Вместо линейной интерполяции используются кубические кривые Эрмита с предсказанием целевой позиции.

### 6.3 Компоненты системы

| Компонент | Назначение |
|-----------|------------|
| EntitySmoother | Управление визуальным состоянием сущностей |
| HermiteSpline | Математика кривых Эрмита |
| PredictionEngine | Client-side prediction для локального игрока |
| SnapshotStore | Буфер серверных снапшотов |
| ServerClock | Синхронизация времени с сервером |

### 6.4 Алгоритм EntitySmoother

**На каждом кадре рендеринга:**

1. **Предсказать целевую позицию:**
   $$P_{target} = P_{snapshot} + V_{snapshot} \cdot (t_{render} - t_{snapshot} + lookAhead)$$

2. **Создать/обновить кривую Эрмита** от текущей визуальной позиции к целевой

3. **Продвинуться вдоль кривой** с адаптивной скоростью:
   - Если отстаём от цели — ускоряемся (catchUpFactor)
   - Если впереди цели — замедляемся

4. **Телепортация** при превышении maxDeviation

### 6.5 Кривые Эрмита

**Базисные функции:**
$$h_{00}(t) = 2t^3 - 3t^2 + 1$$
$$h_{10}(t) = t^3 - 2t^2 + t$$
$$h_{01}(t) = -2t^3 + 3t^2$$
$$h_{11}(t) = t^3 - t^2$$

**Интерполяция позиции:**
$$P(t) = h_{00} \cdot P_0 + h_{10} \cdot V_0 \cdot d + h_{01} \cdot P_1 + h_{11} \cdot V_1 \cdot d$$

где $d$ — длительность кривой, $t \in [0, 1]$.

### 6.6 Конфигурация по типам сущностей

| Параметр | Local Player | Remote Player |
|----------|--------------|---------------|
| lookAheadMs | 30 | 80 |
| transitionDurationMs | 100 | 150 |
| catchUpFactor | 1.0 | 0.5 |
| maxDeviationM | 10 | 50 |

### 6.7 Обработка пропуска снапшотов

При отсутствии новых данных с сервера:
1. До `maxExtrapolationMs` — экстраполяция с текущей скоростью
2. После — плавное затухание скорости до нуля за `transitionDurationMs`

### 6.8 Тороидальный мир

При расчёте кривой учитывается wrap-around:
- Если delta по оси > worldSize/2 — корректировка через противоположную границу
- Применяется к обеим осям независимо

### 6.9 Интерполяция углов

Для rotation используется отдельная кривая с нормализацией дельты угла к [-π, π] для выбора кратчайшего пути.

---

## Ссылки на исходный код

| Модуль | Путь |
|--------|------|
| PhysicsSystem | `src/shared/ECS/Systems/PhysicsSystem.cs` |
| FlightAssistSystem | `src/shared/ECS/Systems/FlightAssistSystem.cs` |
| PhysicsGateway | `src/shared/Physics/PhysicsGateway.cs` |
| RelativisticMath | `src/shared/Physics/RelativisticMath.cs` |
| ShipConfig | `src/shared/Ships/ShipConfig.cs` |
| SharedPhysics | `src/shared/Config/SharedPhysics.cs` |
| TouchInputManager | `src/clients/testbed/chatgpt-vite/client/input/TouchInputManager.ts` |
| SingleJoystickManager | `src/clients/testbed/chatgpt-vite/client/input/SingleJoystickManager.ts` |
| InputTranslator | `src/clients/testbed/chatgpt-vite/client/input/DirectControlMode/InputTranslator.ts` |
| EntitySmoother | `src/clients/testbed/chatgpt-vite/client/world/EntitySmoother.ts` |
| HermiteSpline | `src/clients/testbed/chatgpt-vite/network/HermiteSpline.ts` |
| PredictionEngine | `src/clients/testbed/chatgpt-vite/network/PredictionEngine.ts` |
